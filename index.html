<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Live Camera Makeup Scanner</title>
  <style>
    :root { --panel-bg: rgba(14,14,20,.86); --accent: #a855f7; }
    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background:#0a0a0f; color:#fff; }
    .app { display:grid; grid-template-rows:auto 1fr auto; min-height:100%; }
    header { padding: 14px 16px; border-bottom:1px solid #242438; background:linear-gradient(180deg,#12121a,#0b0b10); }
    header h1 { margin:0; font-size: 18px; letter-spacing:.2px; font-weight: 650; }

    .stage { position: relative; width: min(100%, 980px); margin: 18px auto; aspect-ratio: 16/9; background: #0f0f16; border:1px solid #1e1e2a; border-radius: 16px; overflow: hidden; box-shadow: 0 10px 40px rgba(0,0,0,.45); }
    video, canvas { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; }

    .panel { position: fixed; right: 18px; bottom: 18px; width: 340px; background: var(--panel-bg); backdrop-filter: blur(8px); border: 1px solid #2a2a3c; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.5); }
    .panel header { display:flex; align-items:center; justify-content:space-between; padding:12px 14px; border-bottom:1px solid #2a2a3c; background: transparent; }
    .panel header h2 { margin:0; font-size:14px; font-weight:650; }
    .content { padding: 12px 14px; display: grid; gap: 12px; }
    .row { display:grid; grid-template-columns: 1fr auto; gap: 10px; align-items:center; }
    .row.full { grid-template-columns: 1fr; }
    .row > label { font-size: 13px; color: #cfd2ff; }
    .switch { display:flex; gap:8px; align-items:center; }
    .switch input[type="checkbox"] { width: 18px; height:18px; }
    input[type="color"] { width: 42px; height: 28px; border:1px solid #40405a; background:#0f0f16; border-radius:8px; padding:0; }
    input[type="range"] { width: 100%; accent-color: var(--accent); }
    .buttons { display:flex; gap:8px; }
    button { cursor:pointer; border:1px solid #2a2a3c; background:#12121a; color:#fff; padding:10px 12px; border-radius:12px; font-weight:650; }
    button.primary { background: var(--accent); border-color: transparent; }
    .hint { font-size: 12px; color:#a8a9c5; line-height:1.4; }
    footer { padding: 12px 16px; border-top: 1px solid #232332; color:#a8a9c5; font-size:12px; }
    .badge { display:inline-block; padding:2px 8px; border-radius:999px; background:#1a1a26; border:1px solid #2a2a3c; font-size:11px; color:#cfd2ff; }
    .toast { position: fixed; left:50%; transform:translateX(-50%); bottom: 20px; background: #1a1a26; border:1px solid #33334a; padding:10px 14px; border-radius:10px; font-size:12px; color:#cfd2ff; display:none; }

    /* Preset chips */
    .chip-group { display:flex; flex-wrap:wrap; gap:8px; }
    .chip { font-size:12px; padding:8px 10px; border-radius:999px; border:1px solid #2a2a3c; background:#151520; }
    .chip:hover { filter: brightness(1.1); }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Live Camera Makeup Scanner <span class="badge">Webcam + MediaPipe FaceMesh</span></h1>
    </header>

    <main class="stage" id="stage">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="canvas"></canvas>
    </main>

    <div class="panel" role="region" aria-label="Controls">
      <header>
        <h2>Makeup Controls</h2>
        <div class="buttons">
          <button class="primary" id="btnStart">Start</button>
          <button id="btnStop">Stop</button>
          <button id="btnCapture">Capture</button>
        </div>
      </header>
      <div class="content">
        <div class="row">
          <label for="intensity">Effect intensity</label>
          <input id="intensity" type="range" min="0" max="1" step="0.02" value="0.6" />
        </div>

        <div class="row">
          <label>Makeup On/Off</label>
          <div class="switch"><input id="effectsToggle" type="checkbox" checked/></div>
        </div>

        <div class="row">
          <label>Compare (hold)</label>
          <div class="switch"><button id="btnCompare">Hold to Compare</button></div>
        </div>

        <div class="row">
          <label>Lipstick</label>
          <div class="switch">
            <input id="lipstickToggle" type="checkbox" checked/>
            <input id="lipstickColor" type="color" value="#d11a4a" />
          </div>
        </div>

        <div class="row">
          <label>Blush</label>
          <div class="switch">
            <input id="blushToggle" type="checkbox" checked/>
            <input id="blushColor" type="color" value="#ff6b88" />
          </div>
        </div>

        <div class="row">
          <label>Eyeliner</label>
          <div class="switch">
            <input id="linerToggle" type="checkbox" checked/>
            <input id="linerColor" type="color" value="#000000" />
          </div>
        </div>

        <div class="row full">
          <label>Presets</label>
          <div class="chip-group">
            <button class="chip" id="presetNude">Nude</button>
            <button class="chip" id="presetCoral">Coral</button>
            <button class="chip" id="presetGlam">Glam</button>
            <button class="chip" id="presetReset">Reset</button>
          </div>
        </div>

        <p class="hint">Tip: Host this file (GitHub Pages/Netlify/Vercel) and link to it from your Figma prototype via an <strong>Open link</strong> interaction. Most browsers require HTTPS for camera access. Keyboard: hold <strong>C</strong> or <strong>Space</strong> to compare.</p>
              <div class="row full">
          <label>Diagnostics</label>
          <div class="chip-group">
            <button class="chip" id="btnDiag">Run diagnostics</button>
          </div>
          <pre id="diagOut" style="white-space:pre-wrap;background:#0f0f16;border:1px solid #2a2a3c;border-radius:12px;padding:10px;margin-top:8px;font-size:12px;color:#cfd2ff;max-height:160px;overflow:auto"></pre>
        </div>

        <p class="hint">Tip: Host this file (GitHub Pages/Netlify/Vercel) and link to it from your Figma prototype via an <strong>Open link</strong> interaction. Most browsers require HTTPS for camera access. Keyboard: hold <strong>C</strong> or <strong>Space</strong> to compare.</p>
      </div>
    </div>

    <footer>
      Works best in Chrome / Edge. iOS Safari may ask for permission twice. Face should be wellâ€‘lit and inside frame.
    </footer>
  </div>

  <div class="toast" id="toast"></div>

  <!-- MediaPipe FaceMesh (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

  <script>
    // ---------- UI refs ----------
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('btnStart');
    const stopBtn = document.getElementById('btnStop');
    const captureBtn = document.getElementById('btnCapture');
    const compareBtn = document.getElementById('btnCompare');
    const toast = document.getElementById('toast');

    const intensityEl = document.getElementById('intensity');
    const effectsToggle = document.getElementById('effectsToggle');
    const lipstickToggle = document.getElementById('lipstickToggle');
    const blushToggle = document.getElementById('blushToggle');
    const linerToggle = document.getElementById('linerToggle');
    const lipstickColorEl = document.getElementById('lipstickColor');
    const blushColorEl = document.getElementById('blushColor');
    const linerColorEl = document.getElementById('linerColor');

    // ---------- Presets ----------
    const DEFAULTS = {
      intensity: 0.6, lipColor: '#d11a4a', blushColor: '#ff6b88', linerColor: '#000000',
      lipstickOn: true, blushOn: true, linerOn: true
    };

    const PRESETS = {
      Nude:   { intensity: 0.45, lipColor: '#b87a7a', blushColor: '#ffb3c1', linerColor: '#2b2b2b', lipstickOn: true, blushOn: true, linerOn: false },
      Coral:  { intensity: 0.6,  lipColor: '#ff6f61', blushColor: '#ff8fa3', linerColor: '#1a1a1a', lipstickOn: true, blushOn: true, linerOn: true },
      Glam:   { intensity: 0.85, lipColor: '#b0002a', blushColor: '#ff6b88', linerColor: '#000000', lipstickOn: true, blushOn: true, linerOn: true },
      Reset:  { ...DEFAULTS }
    };

    function applyPreset(name){
      const p = PRESETS[name];
      if(!p) return;
      intensityEl.value = p.intensity;
      lipstickColorEl.value = p.lipColor;
      blushColorEl.value = p.blushColor;
      linerColorEl.value = p.linerColor;
      lipstickToggle.checked = p.lipstickOn;
      blushToggle.checked = p.blushOn;
      linerToggle.checked = p.linerOn;
      effectsToggle.checked = true;
      showToast(`${name} preset applied`);
    }

    // ---------- State ----------
    let camera = null;
    let lastResults = null;
    let compareHold = false; // while true, show original (no makeup)

    function showToast(msg, ms = 2000){
      toast.textContent = msg;
      toast.style.display = 'block';
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => toast.style.display = 'none', ms);
    }

    // ---------- Face regions (indices) ----------
    const LIP_INDICES = [61,185,40,39,37,0,267,269,270,409,291,375,321,405,314,17,84,181,91,146];
    const LEFT_EYE_TOP = [33,160,158,133];
    const RIGHT_EYE_TOP = [362,385,387,263];
    const LEFT_CHEEK = [234,93,132,58,172,136,150,176];
    const RIGHT_CHEEK = [454,323,361,288,397,365,379,400];

    function hexToRgb(hex){
      const m = /^#?([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})$/i.exec(hex);
      return m ? { r: parseInt(m[1],16), g: parseInt(m[2],16), b: parseInt(m[3],16) } : {r:255,g:0,b:0};
    }

    function pathFromIndices(points, indices, w, h){
      ctx.beginPath();
      indices.forEach((i, k) => {
        const p = points[i];
        const x = p.x * w;
        const y = p.y * h;
        if(k === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      });
      ctx.closePath();
    }

    function drawFill(points, indices, color, alpha){
      const {width:w, height:h} = canvas;
      pathFromIndices(points, indices, w, h);
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.fill();
      ctx.restore();
    }

    function drawEyeliner(points, indices, color, thickness){
      const {width:w, height:h} = canvas;
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.lineWidth = thickness;
      ctx.beginPath();
      indices.forEach((i, k) => {
        const p = points[i];
        const x = p.x * w;
        const y = p.y * h;
        if(k === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      });
      ctx.stroke();
      ctx.restore();
    }

    function resizeCanvasToVideo(){
      const rect = video.getBoundingClientRect();
      const ratio = video.videoWidth / video.videoHeight || 16/9;
      canvas.width = rect.width;
      canvas.height = rect.width / ratio;
      if (canvas.height > rect.height) {
        canvas.height = rect.height;
        canvas.width = rect.height * ratio;
      }
    }

    function onResults(results){ lastResults = results; }

    function render(){
      requestAnimationFrame(render);
      if(!lastResults) return;

      const { multiFaceLandmarks } = lastResults;
      if (!multiFaceLandmarks || !multiFaceLandmarks.length) return;

      resizeCanvasToVideo();
      ctx.clearRect(0,0,canvas.width, canvas.height);
      try { ctx.drawImage(video, 0, 0, canvas.width, canvas.height); } catch(e) {}

      if (!effectsToggle.checked || compareHold) return; // show original frame only

      const points = multiFaceLandmarks[0];
      const intensity = parseFloat(intensityEl.value);

      // Lips
      if (lipstickToggle.checked){
        const {r,g,b} = hexToRgb(lipstickColorEl.value);
        drawFill(points, LIP_INDICES, `rgba(${r},${g},${b},1)`, Math.min(0.9, 0.15 + 0.85*intensity));
      }

      // Blush (both cheeks)
      if (blushToggle.checked){
        const {r,g,b} = hexToRgb(blushColorEl.value);
        const alpha = Math.min(0.6, 0.1 + 0.5*intensity);
        drawFill(points, LEFT_CHEEK, `rgba(${r},${g},${b},1)`, alpha);
        drawFill(points, RIGHT_CHEEK, `rgba(${r},${g},${b},1)`, alpha);
      }

      // Eyeliner (upper lash lines)
      if (linerToggle.checked){
        const {r,g,b} = hexToRgb(linerColorEl.value);
        const thickness = 1 + 3*intensity;
        drawEyeliner(points, LEFT_EYE_TOP, `rgba(${r},${g},${b},1)`, thickness);
        drawEyeliner(points, RIGHT_EYE_TOP, `rgba(${r},${g},${b},1)`, thickness);
      }
    }

    async function startCamera(){
      if (!navigator.mediaDevices?.getUserMedia){ showToast('Camera not supported'); return; }
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
        video.srcObject = stream;
        await video.play();
        resizeCanvasToVideo();

        const faceMesh = new FaceMesh.FaceMesh({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}` });
        faceMesh.setOptions({ selfieMode: true, maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        faceMesh.onResults(onResults);

        camera = new CameraUtils.Camera(video, { onFrame: async () => { await faceMesh.send({ image: video }); }, width: 1280, height: 720 });
        camera.start();
        requestAnimationFrame(render);
        showToast('Camera started');
      } catch (e){ console.error(e); showToast('Could not access camera. Check permissions & HTTPS.'); }
    }

    function stopCamera(){
      try { video.srcObject?.getTracks()?.forEach(t => t.stop()); } catch(e) {}
      video.srcObject = null;
      camera?.stop?.();
      camera = null;
      lastResults = null;
      ctx.clearRect(0,0,canvas.width, canvas.height);
      showToast('Camera stopped');
    }

    function captureSnapshot(){
      // download the current canvas (already has video + overlays)
      const name = `makeup_capture_${Date.now()}.png`;
      if (canvas.toBlob){
        canvas.toBlob((blob) => {
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = name;
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(()=>URL.revokeObjectURL(a.href), 2000);
        });
      } else {
        const a = document.createElement('a');
        a.href = canvas.toDataURL('image/png');
        a.download = name;
        document.body.appendChild(a);
        a.click();
        a.remove();
      }
      showToast('Snapshot saved');
    }

    // ---------- events ----------
    const diagBtn = document.getElementById('btnDiag');
    const diagOut = document.getElementById('diagOut');

    async function runDiagnostics(){
      const lines = [];
      function log(k,v){ lines.push(`${k}: ${v}`); }
      log('URL', location.href);
      log('isSecureContext', window.isSecureContext);
      log('Protocol', location.protocol);
      try {
        if (navigator.permissions?.query){
          const p = await navigator.permissions.query({ name: 'camera' });
          log('permissions.query(camera)', p.state);
        } else {
          log('permissions.query', 'not supported');
        }
      } catch(e){ log('permissions.query(camera) error', e?.message || e); }
      try {
        const kinds = {};
        if (navigator.mediaDevices?.enumerateDevices){
          const devs = await navigator.mediaDevices.enumerateDevices();
          devs.forEach(d => kinds[d.kind] = (kinds[d.kind]||0)+1);
          log('devices', JSON.stringify(kinds));
        } else { log('enumerateDevices', 'not supported'); }
      } catch(e){ log('enumerateDevices error', e?.message || e); }
      diagOut.textContent = lines.join('
');
    }

    diagBtn?.addEventListener('click', runDiagnostics);
    startBtn.addEventListener('click', startCamera);
    stopBtn.addEventListener('click', stopCamera);
    captureBtn.addEventListener('click', captureSnapshot);
    window.addEventListener('resize', resizeCanvasToVideo);

    // Compare hold (mouse / touch)
    compareBtn.addEventListener('pointerdown', () => { compareHold = true; });
    compareBtn.addEventListener('pointerup',   () => { compareHold = false; });
    compareBtn.addEventListener('pointerleave',() => { compareHold = false; });

    // Compare hold (keyboard: C or Space)
    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space' || e.key.toLowerCase() === 'c') compareHold = true;
    });
    window.addEventListener('keyup', (e) => {
      if (e.code === 'Space' || e.key.toLowerCase() === 'c') compareHold = false;
    });

    // Preset buttons
    document.getElementById('presetNude').addEventListener('click', () => applyPreset('Nude'));
    document.getElementById('presetCoral').addEventListener('click', () => applyPreset('Coral'));
    document.getElementById('presetGlam').addEventListener('click', () => applyPreset('Glam'));
    document.getElementById('presetReset').addEventListener('click', () => applyPreset('Reset'));

    // Auto-start if permissions previously granted
    if (navigator.permissions && navigator.permissions.query){
      navigator.permissions.query({ name: 'camera' }).then(p => { if (p.state === 'granted') startCamera(); }).catch(()=>{});
    }
  </script>
</body>
</html>
